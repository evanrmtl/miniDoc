
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/evanrmtl/miniDoc/internal/app/Auth/controller.go (87.5%)</option>
				
				<option value="file1">github.com/evanrmtl/miniDoc/internal/app/Auth/service.go (94.7%)</option>
				
				<option value="file2">github.com/evanrmtl/miniDoc/internal/app/WebSocket/controller.go (79.6%)</option>
				
				<option value="file3">github.com/evanrmtl/miniDoc/internal/app/database/database_init.go (0.0%)</option>
				
				<option value="file4">github.com/evanrmtl/miniDoc/internal/app/models/files.go (0.0%)</option>
				
				<option value="file5">github.com/evanrmtl/miniDoc/internal/app/models/sessions.go (0.0%)</option>
				
				<option value="file6">github.com/evanrmtl/miniDoc/internal/app/models/users.go (0.0%)</option>
				
				<option value="file7">github.com/evanrmtl/miniDoc/internal/app/models/users_files.go (0.0%)</option>
				
				<option value="file8">github.com/evanrmtl/miniDoc/internal/middleware/CreateRoute.go (0.0%)</option>
				
				<option value="file9">github.com/evanrmtl/miniDoc/internal/middleware/subroute/AuthRoute.go (0.0%)</option>
				
				<option value="file10">github.com/evanrmtl/miniDoc/internal/middleware/subroute/WSRoute.go (0.0%)</option>
				
				<option value="file11">github.com/evanrmtl/miniDoc/internal/pkg/jwtUtils.go (86.7%)</option>
				
				<option value="file12">github.com/evanrmtl/miniDoc/internal/pkg/sessionUtils.go (71.0%)</option>
				
				<option value="file13">github.com/evanrmtl/miniDoc/main.go (0.0%)</option>
				
				<option value="file14">github.com/evanrmtl/miniDoc/testEnv/db.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "errors"
        "net/http"

        "github.com/evanrmtl/miniDoc/internal/app/models"
        "github.com/evanrmtl/miniDoc/internal/pkg"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func RegisterController(c *gin.Context, db *gorm.DB) <span class="cov8" title="1">{

        ctx := c.Request.Context()

        var req struct {
                Username string `json:"username" binding:"required,min=3,max=20"`
                Password string `json:"password" binding:"required,min=6"`
        }

        err := c.ShouldBindBodyWithJSON(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err = Register(ctx, req.Username, req.Password, db)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, ErrUserExists) </span><span class="cov8" title="1">{
                        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": "Operation unavailable"})
                return</span>
        }

        <span class="cov8" title="1">token, err := pkg.CreateJWT(ctx, req.Username, db)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Couldn't connect, please try again"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated,
                gin.H{
                        "success": "User created",
                        "JWT":     token.Token,
                },
        )

        currUser, err := gorm.G[models.User](db).Where("username = ?", req.Username).First(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">agentUsed := c.GetHeader("User-Agent")

        pkg.CreateSession(currUser.UserID, agentUsed, ctx, db)</span>
}

func LoginController(c *gin.Context, db *gorm.DB) <span class="cov8" title="1">{

        ctx := c.Request.Context()

        var req struct {
                Username string `json:"username" binding:"required"`
                Password string `json:"password" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := Login(ctx, req.Username, req.Password, db)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, ErrUserNotExists) </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "incorrect username"})
                        return
                }</span>
                <span class="cov8" title="1">if errors.Is(err, ErrIncorrectPassword) </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "incorrect password"})
                        return
                }</span>
                <span class="cov8" title="1">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov8" title="1">token, err := pkg.CreateJWT(ctx, req.Username, db)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Couldn't connect, please log in again"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusAccepted,
                gin.H{
                        "success": "User connected",
                        "JWT":     token.Token,
                },
        )

        currUser, err := gorm.G[models.User](db).Where("username = ?", req.Username).First(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">agentUsed := c.GetHeader("User-Agent")

        pkg.CreateSession(currUser.UserID, agentUsed, ctx, db)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "context"
        "errors"

        "golang.org/x/crypto/bcrypt"

        "github.com/evanrmtl/miniDoc/internal/app/models"
        "gorm.io/gorm"
)

var ErrUserExists = errors.New("user already exists")
var ErrUserNotExists = errors.New("user does not exist")
var ErrIncorrectPassword = errors.New("incorrect password")

// Register the user in the database if the username is not already taken.
// Return nil, if it was accepted, the error `ErrUserExists` if the username already exist or, err, the error
func Register(ctx context.Context, username string, password string, db *gorm.DB) error <span class="cov8" title="1">{

        _, err := gorm.G[models.User](db).Where("username = ?", username).First(ctx)
        if err == nil </span><span class="cov8" title="1">{
                return ErrUserExists
        }</span>
        <span class="cov8" title="1">if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = gorm.G[models.User](db).Create(ctx, &amp;models.User{
                Username:     username,
                PasswordHash: string(hashedPassword),
        })
        return err</span>
}

func Login(ctx context.Context, username string, password string, db *gorm.DB) error <span class="cov8" title="1">{

        user, err := gorm.G[models.User](db).Where("username = ?", username).First(ctx)
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return ErrUserNotExists
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
        if err != nil </span><span class="cov8" title="1">{
                return ErrIncorrectPassword
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package websocket

import (
        "encoding/json"
        "errors"
        "log"
        "net/http"

        "github.com/evanrmtl/miniDoc/internal/pkg"
        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        "gorm.io/gorm"
)

const (
        MessageTypeAuthSuccess = "Auth_success"
        MessageTypeAuthFailed  = "Auth_failed"
)

type Socket struct {
        conn *websocket.Conn
        c    *gin.Context
}

type AuthResponse struct {
        Type string      `json:"type"`
        Data interface{} `json:"data"`
}

type AuthSuccessData struct {
        Token   string `json:"token,omitempty"`
        Renewed bool   `json:"renewed"`
}

func WebSocketHandler(c *gin.Context, db *gorm.DB) <span class="cov8" title="1">{

        upgrader := websocket.Upgrader{
                CheckOrigin: func(r *http.Request) bool </span><span class="cov8" title="1">{
                        return true
                }</span>,
                EnableCompression: true,
        }

        <span class="cov8" title="1">conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.AbortWithError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov8" title="1">defer conn.Close()
        socket := Socket{conn: conn, c: c}
        for </span><span class="cov8" title="1">{
                messageType, msg, err := conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        log.Println(err)
                        return
                }</span>
                <span class="cov8" title="1">go processMessage(messageType, msg, socket, db)</span>
        }
}

func processMessage(messageType int, msg []byte, socket Socket, db *gorm.DB) <span class="cov8" title="1">{
        switch messageType </span>{
        case websocket.TextMessage:<span class="cov8" title="1">
                processTextMessage(msg, socket, db)</span>
        }
}

func processTextMessage(msg []byte, socket Socket, db *gorm.DB) <span class="cov8" title="1">{
        var typeMessage struct {
                Type string
        }
        err := json.Unmarshal(msg, &amp;typeMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("unmarshall type webosocket impossible")
                return
        }</span>
        <span class="cov8" title="1">switch typeMessage.Type </span>{
        case "auth":<span class="cov8" title="1">
                processAuthRequest(msg, socket, db)</span>
        }
}

func processAuthRequest(msg []byte, socket Socket, db *gorm.DB) <span class="cov8" title="1">{
        type DataRequest struct {
                Token    string
                Username string
                UserID   uint32
        }

        var data struct {
                DataRequest DataRequest
        }

        err := json.Unmarshal(msg, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error unmarshalling token request:", err)
                return
        }</span>

        <span class="cov8" title="1">ctx := socket.c.Request.Context()
        agent := socket.c.Request.UserAgent()

        err = pkg.ValidJWT(data.DataRequest.Token, agent, ctx, db)

        if err != nil &amp;&amp; !errors.Is(err, pkg.ErrJWTExpired) </span><span class="cov8" title="1">{
                socket.sendAuthError()
                return
        }</span>

        <span class="cov8" title="1">pkg.CreateSession(data.DataRequest.UserID, agent, ctx, db)

        if errors.Is(err, pkg.ErrJWTExpired) </span><span class="cov8" title="1">{
                newToken, err := pkg.CreateJWT(ctx, data.DataRequest.Username, db)
                if err != nil </span><span class="cov0" title="0">{
                        socket.sendAuthError()
                        return
                }</span>

                <span class="cov8" title="1">response := AuthResponse{
                        Type: MessageTypeAuthSuccess,
                        Data: AuthSuccessData{
                                Token:   newToken.Token,
                                Renewed: true,
                        },
                }

                err = socket.conn.WriteJSON(response)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Failed to send auth success")
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">response := AuthResponse{
                Type: MessageTypeAuthSuccess,
                Data: AuthSuccessData{
                        Renewed: false,
                },
        }

        err = socket.conn.WriteJSON(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send auth success")
        }</span>
}

func (s *Socket) sendAuthError() <span class="cov8" title="1">{
        response := AuthResponse{
                Type: MessageTypeAuthFailed,
                Data: nil,
        }
        err := s.conn.WriteJSON(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to send auth error")
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package generate

import (
        "fmt"
        "log"
        "os"

        "github.com/evanrmtl/miniDoc/internal/app/models"
        "github.com/joho/godotenv"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func GenerateDB() *gorm.DB <span class="cov0" title="0">{

        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(".env file not founded or error loading it")</span>
        }

        <span class="cov0" title="0">host := os.Getenv("DB_HOST")
        user := os.Getenv("DB_USER")
        password := os.Getenv("DB_PASSWORD")
        dbname := os.Getenv("DB_NAME")
        port := os.Getenv("DB_PORT")
        sslmode := os.Getenv("DB_SSLMODE")

        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s", host, user, password, dbname, port, sslmode)
        fmt.Println(dsn)

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("couldn't open the database : %v", err))</span>
        }

        <span class="cov0" title="0">err = db.AutoMigrate(
                &amp;models.UserMigration{},
                &amp;models.FileMigration{},
                &amp;models.SessionMigration{},
                &amp;models.UsersFileMigration{},
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("error when migrating models")
        }</span>

        <span class="cov0" title="0">err = db.Exec("ALTER TABLE users_files ADD CONSTRAINT fk_users_files_user_id FOREIGN KEY (user_id) REFERENCES users(user_id)").Error
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: constraint fk_users_files_user_id already exist or error while creating it : %v", err)
        }</span>

        <span class="cov0" title="0">err = db.Exec("ALTER TABLE users_files ADD CONSTRAINT fk_users_files_file_id FOREIGN KEY (file_id) REFERENCES files(file_id)").Error
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: constraint fk_users_files_file_id already exist or error while creating it : %v", err)
        }</span>

        <span class="cov0" title="0">err = db.Exec("ALTER TABLE sessions ADD CONSTRAINT fk_session_user_id FOREIGN KEY (user_id) REFERENCES users(user_id)").Error
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: constraint fk_session_user_id already exist or error while creating it : %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Migration successful")

        return db</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

const TableNameFile = "files"

// File mapped from table &lt;files&gt;
type FileMigration struct {
        FileID        uint32 `gorm:"column:file_id;primaryKey" json:"file_id"`
        FileName      string `gorm:"column:file_name" json:"file_name"`
        FileContent   string `gorm:"column:file_content" json:"file_content"`
        FileUpdatedAt int64  `gorm:"column:file_updated_at" json:"file_updated_at"`
}

// TableName File's table name
func (*FileMigration) TableName() string <span class="cov0" title="0">{
        return TableNameFile
}</span>

type File struct {
        FileID        uint32 `gorm:"column:file_id;primaryKey" json:"file_id"`
        FileName      string `gorm:"column:file_name" json:"file_name"`
        FileContent   string `gorm:"column:file_content" json:"file_content"`
        FileUpdatedAt int64  `gorm:"column:file_updated_at" json:"file_updated_at"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

const TableNameSession = "sessions"

type SessionMigration struct {
        SessionID uint32 `gorm:"column:session_id;primaryKey" json:"session_id"`
        UserID    uint32 `gorm:"column:user_id" json:"user_id"`
        CreatedAt int64  `gorm:"column:created_at" json:"created_at"`
        ExpiresAt int64  `gorm:"column:expires_at" json:"expires_at"`
        Agent     string `gorm:"column:agent" json:"agent"`
}

func (*SessionMigration) TableName() string <span class="cov0" title="0">{
        return TableNameSession
}</span>

type Session struct {
        SessionID uint32 `gorm:"column:session_id;primaryKey" json:"session_id"`
        UserID    uint32 `gorm:"column:user_id" json:"user_id"`
        CreatedAt int64  `gorm:"column:created_at" json:"created_at"`
        ExpiresAt int64  `gorm:"column:expires_at" json:"expires_at"`
        Agent     string `gorm:"column:agent" json:"agent"`
        User      User   `gorm:"foreignKey:UserID"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

const TableNameUser = "users"

// User mapped from table &lt;users&gt;
type UserMigration struct {
        UserID       uint32 `gorm:"column:user_id;primaryKey" json:"user_id"`
        Username     string `gorm:"column:username;not null;uniqueIndex;size:20" json:"username" binding:"required,min=3,max=20"`
        PasswordHash string `gorm:"column:password_hash;not null" json:"password_hash"`
}

// TableName User's table name
func (*UserMigration) TableName() string <span class="cov0" title="0">{
        return TableNameUser
}</span>

type User struct {
        UserID       uint32      `gorm:"column:user_id;primaryKey" json:"user_id"`
        Username     string      `gorm:"column:username;not null" json:"username"`
        PasswordHash string      `gorm:"column:password_hash;not null" json:"password_hash"`
        UsersFiles   []UsersFile `gorm:"foreignKey:UserID"`
        Session      []Session   `gorm:"foreignKey:UserID"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import "errors"

const TableNameUsersFile = "users_files"

const (
        RoleOwner        = "Owner"
        RoleCollaborator = "Collaborator"
)

// UsersFile mapped from table &lt;users_files&gt;
type UsersFileMigration struct {
        UserID uint32 `gorm:"column:user_id;primaryKey;not null" json:"user_id"`
        FileID uint32 `gorm:"column:file_id;primaryKey;not null" json:"file_id"`
        Role   string `gorm:"column:role;default:Collaborator" json:"role"`
}

// TableName UsersFile's table name
func (*UsersFileMigration) TableName() string <span class="cov0" title="0">{
        return TableNameUsersFile
}</span>

func (uf *UsersFileMigration) Validate() error <span class="cov0" title="0">{
        switch uf.Role </span>{
        case RoleOwner, RoleCollaborator:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("role must be Owner or Collaborator")</span>
        }
}

type UsersFile struct {
        UserID uint32 `gorm:"column:user_id;primaryKey;not null" json:"user_id"`
        FileID uint32 `gorm:"column:file_id;primaryKey;not null" json:"file_id"`
        Role   string `gorm:"column:role;default:Collaborator" json:"role"`
        File   File   `gorm:"foreignKey:FileID"`
        User   User   `gorm:"foreignKey:UserID"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package routes

import (
        "time"

        "github.com/evanrmtl/miniDoc/internal/middleware/subroute"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func CreateRoutes(db *gorm.DB) *gin.Engine <span class="cov0" title="0">{
        router := gin.Default()

        config := cors.DefaultConfig()
        config.AllowOrigins = []string{"http://localhost:4200"}
        config.AllowMethods = []string{"POST", "GET", "OPTIONS"}
        config.AllowHeaders = []string{"Origin", "Content-Type", "Authorization"}
        config.ExposeHeaders = []string{"Content-Length"}
        config.AllowCredentials = true
        config.MaxAge = 12 * time.Hour

        router.Use(cors.New(config))

        subroute.CreateAuthRoutes(router, db)
        subroute.CreateWSRoute(router, db)

        return router
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package subroute

import (
        auth "github.com/evanrmtl/miniDoc/internal/app/Auth"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func CreateAuthRoutes(router *gin.Engine, db *gorm.DB) <span class="cov0" title="0">{
        router.POST("/register", func(c *gin.Context) </span><span class="cov0" title="0">{
                auth.RegisterController(c, db)
        }</span>)

        <span class="cov0" title="0">router.POST("/login", func(c *gin.Context) </span><span class="cov0" title="0">{
                auth.LoginController(c, db)
        }</span>)
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package subroute

import (
        websocket "github.com/evanrmtl/miniDoc/internal/app/WebSocket"
        "gorm.io/gorm"

        "github.com/gin-gonic/gin"
)

func CreateWSRoute(router *gin.Engine, db *gorm.DB) <span class="cov0" title="0">{
        router.GET("/ws", func(c *gin.Context) </span><span class="cov0" title="0">{
                websocket.WebSocketHandler(c, db)
        }</span>)
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package pkg

import (
        "context"
        "crypto"
        "encoding/base64"
        "encoding/json"
        "errors"
        "os"
        "strings"

        "time"

        "github.com/evanrmtl/miniDoc/internal/app/models"
        golangjwt "github.com/golang-jwt/jwt/v5"
        "gorm.io/gorm"
)

type jwtHeader struct {
        Alg string `json:"alg"`
        Typ string `json:"typ"`
}

type jwtPayload struct {
        Username  string `json:"username"`
        UserID    uint32 `json:"userId"`
        Iat       int64  `json:"iat"`
        ExpiresAt int64  `json:"expiresAt"`
}

type JWTToken struct {
        Token string
}

var signingMethod = golangjwt.SigningMethodRSA{
        Name: "generateSignature",
        Hash: crypto.SHA256,
}

var (
        ErrJWTHeaderMarshal    = errors.New("failed to marshal JWT header to JSON")
        ErrJWTPayloadMarshal   = errors.New("failed to marshal JWT payload to JSON")
        ErrUserNotFound        = errors.New("user not found in database")
        ErrInvalidPrivateKey   = errors.New("failed to parse RSA private key from PEM")
        ErrJWTSigning          = errors.New("failed to sign JWT")
        ErrInvalidJWTFormat    = errors.New("invalid JWT: incorrect number of segments")
        ErrSignatureDecode     = errors.New("failed to decode signature")
        ErrInvalidPublicKey    = errors.New("failed to parse public key")
        ErrInvalidJWTSignature = errors.New("invalid JWT: incorrect token")
        ErrPayloadDecode       = errors.New("failed to decode payload")
        ErrPayloadUnmarshal    = errors.New("failed to unmarshall payload")
        ErrTokenExpired        = errors.New("token expired and no active session found")
        ErrSessionLookup       = errors.New("session lookup failed")
        ErrJWTExpired          = errors.New("JWT has expired but session not expired")
)

func CreateJWT(ctx context.Context, username string, db *gorm.DB) (JWTToken, error) <span class="cov8" title="1">{
        var jwtToken JWTToken

        header := jwtHeader{
                Alg: "RS256",
                Typ: "JWT",
        }

        headerJSON, err := json.Marshal(header)
        if err != nil </span><span class="cov0" title="0">{
                return jwtToken, ErrJWTHeaderMarshal
        }</span>

        <span class="cov8" title="1">headerBase64 := base64.RawURLEncoding.EncodeToString(headerJSON)

        user, err := gorm.G[models.User](db).Where("username = ?", username).First(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return jwtToken, ErrUserNotFound
        }</span>

        <span class="cov8" title="1">currentTime := time.Now()
        payload := jwtPayload{
                Username:  username,
                UserID:    user.UserID,
                Iat:       currentTime.Unix(),
                ExpiresAt: currentTime.Add(time.Hour * 24 * 15).Unix(),
        }

        payloadJSON, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return jwtToken, ErrJWTPayloadMarshal
        }</span>

        <span class="cov8" title="1">payloadBase64 := base64.RawURLEncoding.EncodeToString(payloadJSON)

        signatureBase64, err := createSignature(headerBase64, payloadBase64)
        if err != nil </span><span class="cov0" title="0">{
                return jwtToken, err
        }</span>

        <span class="cov8" title="1">fullJWT := headerBase64 + "." + payloadBase64 + "." + signatureBase64
        jwtToken.Token = fullJWT

        return jwtToken, nil</span>
}

func createSignature(header string, payload string) (string, error) <span class="cov8" title="1">{
        privateKeyPEM := []byte(strings.ReplaceAll(os.Getenv("RS256_PRIVATE_KEY"), `\n`, "\n"))
        privateKey, err := golangjwt.ParseRSAPrivateKeyFromPEM(privateKeyPEM)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrInvalidPrivateKey
        }</span>

        <span class="cov8" title="1">dataToSign := header + "." + payload

        signature, err := signingMethod.Sign(dataToSign, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrJWTSigning
        }</span>

        <span class="cov8" title="1">signatureBase64 := base64.RawURLEncoding.EncodeToString(signature)

        return signatureBase64, nil</span>
}

func ValidJWT(token string, agent string, ctx context.Context, db *gorm.DB) error <span class="cov8" title="1">{
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return ErrInvalidJWTFormat
        }</span>
        <span class="cov8" title="1">dataToVerify := parts[0] + "." + parts[1]

        dataToFind, err := base64.RawURLEncoding.DecodeString(parts[2])
        if err != nil </span><span class="cov8" title="1">{
                return ErrSignatureDecode
        }</span>

        <span class="cov8" title="1">PEMPublicKey := []byte(strings.ReplaceAll(os.Getenv("RS256_PUBLIC_KEY"), `\n`, "\n"))
        publicKey, err := golangjwt.ParseRSAPublicKeyFromPEM(PEMPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidPublicKey
        }</span>

        <span class="cov8" title="1">err = signingMethod.Verify(dataToVerify, dataToFind, publicKey)
        if err != nil </span><span class="cov8" title="1">{
                return ErrInvalidJWTSignature
        }</span>
        <span class="cov8" title="1">decodedPayload, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return ErrPayloadDecode
        }</span>
        <span class="cov8" title="1">var payload jwtPayload
        err = json.Unmarshal(decodedPayload, &amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                return ErrJWTPayloadMarshal
        }</span>

        <span class="cov8" title="1">if time.Now().Unix() &gt; payload.ExpiresAt </span><span class="cov8" title="1">{
                session, err := gorm.G[models.Session](db).
                        Where("agent = ?", agent).
                        Where("user_id = ?", payload.UserID).
                        Where("expires_at &gt; ?", time.Now().Unix()).
                        Find(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrSessionLookup
                }</span>
                <span class="cov8" title="1">if len(session) == 0 </span><span class="cov8" title="1">{
                        return ErrTokenExpired
                }</span>
                <span class="cov8" title="1">return ErrJWTExpired</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package pkg

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/evanrmtl/miniDoc/internal/app/models"
        "gorm.io/gorm"
)

func CreateSession(userID uint32, agent string, ctx context.Context, db *gorm.DB) <span class="cov8" title="1">{
        session, err := gorm.G[models.Session](db).
                Where("user_id = ?", userID).
                Where("agent = ?", agent).
                First(ctx)
        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                log.Println("error on retrieve session request")
                return
        }</span>
        // If no record found, then create
        <span class="cov8" title="1">if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                currentTime := time.Now()
                err = gorm.G[models.Session](db).Create(ctx, &amp;models.Session{
                        UserID:    userID,
                        CreatedAt: currentTime.Unix(),
                        ExpiresAt: currentTime.Add(time.Hour * 24 * 15).Unix(),
                        Agent:     agent,
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("erros while creating the session")
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">err = UpdateSessionTime(&amp;session, ctx, db)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>
}

func UpdateSessionTime(session *models.Session, ctx context.Context, db *gorm.DB) error <span class="cov8" title="1">{
        newExpiration := time.Now().Add(time.Hour * 24 * 15).Unix()
        _, err := gorm.G[models.Session](db).
                Where("session_id = ?", session.SessionID).
                Updates(ctx, models.Session{
                        ExpiresAt: newExpiration,
                })
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error on update time")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func DeleteExpiredSession(ctx context.Context, db *gorm.DB) <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Hour * 24)
        defer ticker.Stop()

        deleteExpiredSessions(ctx, db)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        fmt.Println("DeleteExpiredSession stopped:", ctx.Err())
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        deleteExpiredSessions(ctx, db)</span>
                }
        }
}

func deleteExpiredSessions(ctx context.Context, db *gorm.DB) <span class="cov8" title="1">{
        _, err := gorm.G[models.Session](db).
                Where("expires_at &lt; ?", time.Now().Unix()).
                Delete(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error deleting expired sessions: %v\n", err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        generate "github.com/evanrmtl/miniDoc/internal/app/database"
        routes "github.com/evanrmtl/miniDoc/internal/middleware"
        "github.com/evanrmtl/miniDoc/internal/pkg"
)

func main() <span class="cov0" title="0">{

        db := generate.GenerateDB()
        _, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("error when connecting to the Database: %s", err.Error())
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        go pkg.DeleteExpiredSession(ctx, db)

        srv := &amp;http.Server{Addr: ":3000", Handler: routes.CreateRoutes(db)}
        go func() </span><span class="cov0" title="0">{
                err := srv.ListenAndServe()
                if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("serveur arrÃªt: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

        &lt;-sigCh
        cancel()

        shutdownCtx, _ := context.WithTimeout(context.Background(), 10*time.Second)
        srv.Shutdown(shutdownCtx)

        log.Println("Shutdown requested, server and routines shut down cleanly.")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package testenv

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/evanrmtl/miniDoc/internal/app/models"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/wait"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

var (
        DB        *gorm.DB
        container testcontainers.Container
)

func Setup() error <span class="cov0" title="0">{
        ctx := context.Background()

        req := testcontainers.ContainerRequest{
                Image:        "postgres:15",
                ExposedPorts: []string{"5432/tcp"},
                Env: map[string]string{
                        "POSTGRES_DB":       "testdb",
                        "POSTGRES_PASSWORD": "password",
                        "POSTGRES_USER":     "postgres",
                },
                WaitingFor: wait.ForLog("database system is ready to accept connections").
                        WithOccurrence(2).WithStartupTimeout(30 * time.Second),
        }

        var err error
        container, err = testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
                ContainerRequest: req,
                Started:          true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start container: %w", err)
        }</span>

        <span class="cov0" title="0">host, err := container.Host(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get container host: %w", err)
        }</span>

        <span class="cov0" title="0">port, err := container.MappedPort(ctx, "5432")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get container port: %w", err)
        }</span>

        <span class="cov0" title="0">dsn := fmt.Sprintf("host=%s port=%s user=postgres password=password dbname=testdb sslmode=disable",
                host, port.Port())

        DB, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Silent),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">err = DB.AutoMigrate(
                &amp;models.UserMigration{},
                &amp;models.FileMigration{},
                &amp;models.SessionMigration{},
                &amp;models.UsersFileMigration{},
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("error when migrating models")
        }</span>

        <span class="cov0" title="0">err = DB.Exec("ALTER TABLE users_files ADD CONSTRAINT fk_users_files_user_id FOREIGN KEY (user_id) REFERENCES users(user_id)").Error
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: constraint fk_users_files_user_id already exist or error while creating it : %v", err)
        }</span>

        <span class="cov0" title="0">err = DB.Exec("ALTER TABLE users_files ADD CONSTRAINT fk_users_files_file_id FOREIGN KEY (file_id) REFERENCES files(file_id)").Error
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: constraint fk_users_files_file_id already exist or error while creating it : %v", err)
        }</span>

        <span class="cov0" title="0">err = DB.Exec("ALTER TABLE sessions ADD CONSTRAINT fk_session_user_id FOREIGN KEY (user_id) REFERENCES users(user_id)").Error
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: constraint fk_session_user_id already exist or error while creating it : %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Teardown() <span class="cov0" title="0">{
        if container != nil </span><span class="cov0" title="0">{
                container.Terminate(context.Background())
        }</span>
}

func CleanTables() <span class="cov0" title="0">{
        if DB != nil </span><span class="cov0" title="0">{
                DB.Exec("TRUNCATE users RESTART IDENTITY CASCADE")
                DB.Exec("TRUNCATE users_files RESTART IDENTITY CASCADE")
                DB.Exec("TRUNCATE files RESTART IDENTITY CASCADE")
                DB.Exec("TRUNCATE session RESTART IDENTITY CASCADE")
        }</span>
}

func GetDSN() string <span class="cov0" title="0">{
        if container == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        host, _ := container.Host(ctx)
        port, _ := container.MappedPort(ctx, "5432")

        return fmt.Sprintf("host=%s port=%s user=postgres password=password dbname=testdb sslmode=disable",
                host, port.Port())</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
